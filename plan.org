#+TITLE: Programable Tanks 2

* Overview
this is my second attempt to create a game/simulation of AI tank combat.

in my last attempt, I was bogged down with creating a graphics frontend first
and then attaching the logic to the backend. I never really got around to
implementing the logic because of this.

With this project, I will start with creating the game logic/backend first, then
add the graphics front end. To visualize what is going on, I will certainly
implement a simple TUI.

* Core Constructs
To start, the scope of these core concepts will be constrained. The mechanics
will be similar to the online MMO Screeps.

** Tanks
can have different attributes which give it abilities.
- Movement
- Attack
- Cargo
- Sensor Packages

** World
   A map of the world does not necessarily need to be maintained. However, a list
of world objects will need to be maintained.

position updates and actions will need to be validated to ensure there are no
conflicts or intersections.

** Threading
This program will be multithreaded. Threads may be used to send commands, run
callbacks, etc.

*** World Update Thread
every game tick, all world object positions will be updated.

*** Networking Thread
connected clients need to be able to receive game information from the server
and send updates to the server.

Unlike Screeps, where all processing is done on the server, Programable Tanks
will use distributed computation. For a player's game objects to be updated, the
client must send the updates to the server. Of course, these updates will be
validated to ensure that no nefarious activity is performed by the player.

*** Server Graphics Thread

* Gameplay
  tanks are the fundamental unit to this game. They are remote controlled, yet
  programable. That is, once spawned, a tank will not do anything on its
  own. Every tick, it must be given instructions. The player may submit
  instructions over the network as frequent or infrequently as they desire.

  
   - establish production?
   - control zones?
   - fight battles?

   Perhaps the gameplay could be modeled after =Escape from Tarkov=, or =Dayz=.
   No production would have to be constantly monitored, and there could be a
   variety of different game modes.

   You could have different "rooms," "scenarios," "insertion points,"
   etc. essentially these would be different coordinate spaces for tanks, and is
   where any given scenario would run. You would be given information about the
   scenario before hand, and you would have to prep your tank team
   accordingly. Once inserted, your tank team would not be able to recieve
   resupply, and would have to complete the mission the be extracted. players
   would always have a certain number of basic tanks, /but upgrades could be
   found on the battle field and be equipped between scenarios./ (This mechanic,
   sourced from escape from tarkov, may or may not be necessary.)

   players would want to write scripts to control their tanks, and allow them to
   manage the battlefield semi autonomously. The battlefields will be relatively
   large, and ticks ideally would occur relatively often, so the tank commander
   will want to have strategic level control at game time. tactical level
   control should be controled programmatically.

** Scenarios or Battlefields
   not entirely sure about the nomenclature just yet. A battlefield may have
   multiple objectives available. Only one objective will be shown per
   player. An objective may be to defend a certain object or area, or perhaps
   the objective is to take that area. multiple players will enter the
   battlefield, and their objectives may or may not conflict with each
   other. However, the possible number of objectives will be fixed, so players
   can develop programs for specific objectives.


** Objectives
   These are the objectives that will be available to players in any given
   battlefield.
   
*** Defend / Destroy Structure
    
*** Capture the Flag

*** Kill Enenmy Tanks

* Program Structure
  
** Connection Manager
   Initial layer, where incoming connections and data packets are recieved and
   deserialized. Once the deserialization and post processing is done, the
   resulting data is sent to the client manager layer.

** Player Client Manager
   After the packet has been reconstructed and is passed to this layer, player
   managers will track the state of a player (what scenario are they in, player
   data, etc.) and handle the messages that the player is sending the server.

** Scenario Manager
   If the player is in a scenario, then scenario messages will be sent to the
   applicable scenario layer to be validated and applied. It is in the scenario
   where tank positions will be updated or scheduled.
    
* Networking API
This is meant to be a multiplayer game/simulation. While all player operations
will be validated by the server, the processing required to determine those
moves must be done by the clients.

The messages that may be sent over the network to exchange information are
described in this section.

Every client connected to the server will have its state tracked. When a network
connection is made to the server, it must first authenticate itself as a
particular user before any other messages will be accepted. *for now, it is
sufficient to simply provide a name, there is no security.* 

** Connection State Diagram
*** STATE_IDLE
    this state is used for "players" who have made a network connection to the
    server, but have yet to be authenticated. The only way to move out of this
    state is to send an authenticate message which provides the user
    authentication.
    
*** STATE_LOBBY
    The player has been authenticated and can view all the scenarios which are
    currently active, join a scenario, or create a new scenario.

    
*** STATE_SCENARIO
    After creating or joining a scenario, the player can do normal gameplay
    things. 

** Client Connection Request
for now, clients will self-identify, and no authentication will be done. In the
future, there should be some sort of traffic encryption and authentication to
protect OPSEC for individual players.

** Client Map Request
client requests map data from the server. The server will provide all map
information. Future iterations of the sim may limit the amount of the map that
is revealed; visible portions may be limited by the player's area of control.

for now, the server will provide a *complete listing of game object locations*.

** Client Update Request
the client will update parameters on specific game objects.

** Server Validation Response
The server sends this message in response to a position update request. This
response indicates whether the proposed update was accepted.

The server should enumerate which game object updates were valid and which ones
were invalid.
