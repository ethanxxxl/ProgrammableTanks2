#+TITLE: Programable Tanks 2

* Overview
  this is my second attempt to create a game/simulation of AI tank combat.

  in my last attempt, I was bogged down with creating a graphics frontend first
  and then attaching the logic to the backend. I never really got around to
  implementing the logic because of this.

  With this project, I will start with creating the game logic/backend first,
  then add the graphics front end. To visualize what is going on, I will
  certainly implement a simple TUI.

* Core Constructs
  To start, the scope of these core concepts will be constrained. The mechanics
  will be similar to the online MMO Screeps.

** Tanks
   can have different attributes which give it abilities.
   - Movement
   - Attack
   - Cargo
   - Sensor Packages

** World
   A map of the world does not necessarily need to be maintained. However, a
   list of world objects will need to be maintained.

   position updates and actions will need to be validated to ensure there are no
   conflicts or intersections.

** Threading
   This program will be multithreaded. Threads may be used to send commands, run
   callbacks, etc.

*** World Update Thread
every game tick, all world object positions will be updated.

*** Networking Thread
connected clients need to be able to receive game information from the server
and send updates to the server.

Unlike Screeps, where all processing is done on the server, Programable Tanks
will use distributed computation. For a player's game objects to be updated, the
client must send the updates to the server. Of course, these updates will be
validated to ensure that no nefarious activity is performed by the player.

*** Server Graphics Thread

* Gameplay
  tanks are the fundamental unit to this game. They are remote controlled, yet
  programable. That is, once spawned, a tank will not do anything on its
  own. Every tick, it must be given instructions. The player may submit
  instructions over the network as frequent or infrequently as they desire.

  
   - establish production?
   - control zones?
   - fight battles?

   Perhaps the gameplay could be modeled after =Escape from Tarkov=, or =Dayz=.
   No production would have to be constantly monitored, and there could be a
   variety of different game modes.

   You could have different "rooms," "scenarios," "insertion points,"
   etc. essentially these would be different coordinate spaces for tanks, and is
   where any given scenario would run. You would be given information about the
   scenario before hand, and you would have to prep your tank team
   accordingly. Once inserted, your tank team would not be able to recieve
   resupply, and would have to complete the mission the be extracted. players
   would always have a certain number of basic tanks, /but upgrades could be
   found on the battle field and be equipped between scenarios./ (This mechanic,
   sourced from escape from tarkov, may or may not be necessary.)

   players would want to write scripts to control their tanks, and allow them to
   manage the battlefield semi autonomously. The battlefields will be relatively
   large, and ticks ideally would occur relatively often, so the tank commander
   will want to have strategic level control at game time. tactical level
   control should be controled programmatically.

** Scenarios or Battlefields
   not entirely sure about the nomenclature just yet. A battlefield may have
   multiple objectives available. Only one objective will be shown per
   player. An objective may be to defend a certain object or area, or perhaps
   the objective is to take that area. multiple players will enter the
   battlefield, and their objectives may or may not conflict with each
   other. However, the possible number of objectives will be fixed, so players
   can develop programs for specific objectives.


** Objectives
   
   These are the objectives that will be available to players in any given
   battlefield.
   
*** Defend / Destroy Structure
    
*** Capture the Flag

*** Kill Enenmy Tanks


    
** Tank Mechanics
   Every tick/turn, a tank can complete one of these (mutually
   exclusive) actions:
   - Movement
   - Firing
   - Repair

     The server will resolve healing first, followed by movement, then firing.

* Program Structure
** DONE File Structure
   <2024-01-06 Sat>

   as the program as grown more complex, I found the need to reorganize the file
   structure, especially considering the abysmal state of ~client.c~. Below I
   consider two options for how to structure the filesystem. I ended up going
   with option 2.
*** Option 1
   keep all sources together. keep all includes together.
   
   - include/
     + client-headers/
     + server-headers/
     + common-header-1
     + common-header-2
     + ...
   - src/
     + client-src/
     + server-src/
     + common-src-1
     + common-src-2

*** Option 2
    separate out the binaries, but keep the translation units common
    to both in a separate include.
   
    - include/
      + common-header-1
      + common-header-2
    - src/
      + common-src-1
      + common-src-2
       
    - client/
      + include/
      + src/
    - server/
      + include/
      + src/

    really what you are doing here is just creating multiple binaries and a
    couple libraries. I like option 2 better.
    
** Connection Manager
   Initial layer, where incoming connections and data packets are received and
   deserialized. Once the deserialization and post-processing is done, the
   resulting data is sent to the client manager layer.

** Player Client Manager
   After the packet has been reconstructed and is passed to this layer, player
   managers will track the state of a player (what scenario are they in, player
   data, etc.) and handle the messages that the player is sending the server.

** Scenario Manager
   If the player is in a scenario, then scenario messages will be sent to the
   applicable scenario layer to be validated and applied. It is in the scenario
   where tank positions will be updated or scheduled.
    
* Networking API
  This is meant to be a multiplayer game/simulation. While all player operations
  will be validated by the server, the processing required to determine those
  moves must be done by the clients.

  The messages that may be sent over the network to exchange information are
  described in this section.

  Every client connected to the server will have its state tracked. When a
  network connection is made to the server, it must first authenticate itself as
  a particular user before any other messages will be accepted. *for now, it is
  sufficient to simply provide a name, there is no security.*

** Connection State Diagram
*** STATE_IDLE
    this state is used for "players" who have made a network connection to the
    server, but have yet to be authenticated. The only way to move out of this
    state is to send an authenticate message which provides the user
    authentication.
    
*** STATE_LOBBY
    The player has been authenticated and can view all the scenarios which are
    currently active, join a scenario, or create a new scenario.

*** STATE_SCENARIO
    After creating or joining a scenario, the player can do normal gameplay
    things. 

** DONE Client Connection Request
   for now, clients will self-identify, and no authentication will be done. In
   the future, there should be some sort of traffic encryption and
   authentication to protect OPSEC for individual players.

** TODO Client Map Request
   client requests map data from the server. The server will provide all map
   information. Future iterations of the sim may limit the amount of the map
   that is revealed; visible portions may be limited by the player's area of
   control.

   for now, the server will provide a *complete listing of game object
   locations*.

** TODO Client Update Request
   the client will update parameters on specific game objects.

** TODO Server Validation Response
   The server sends this message in response to a position update request. This
   response indicates whether the proposed update was accepted.

   The server should enumerate which game object updates were valid and which
   ones were invalid.

** Message Structure
   I need to be able to receive and send messages. I have a bunch of message types.

   What you have going on currently?
   you have three functions:
   - send_message
   - recv_message
   - message_length

   #+begin_src c
     /// place to remember to update
     enum message_type {
         ...
     };

     struct message {
         enum message_type type;
         union msg_data { ... };
     };

     /// place to remember to update
     int message_len(struct message* msg) {
         switch (msg->type) {

         }
     }

     /// place to remember to update
     void send_message(enum message_type* msg) {
         switch (msg->type) {
             ...
                 }
     }

     /// place to remember to update
     void rcv_message(struct message* msg) {
         switch (msg->type) {
             ...
                 }
     }

     /// place to remember to update
     void free_message(struct message* msg) {
         switch (msg->type) {
             ...
                 }
     }
   #+end_src

   With this setup, there are 5 places I have to remember to update every time I
   want to add a message. This is too much, and I have already been bitten in the
   butt because of it. There needs to be a more consolidated way to add new
   messages.

   This style is also confusing because it is not certain which union fields go
   with which message types, especially since not all message types are even
   associated with a union field.

   #+begin_src c
     // place to update for a new message
     enum message_type {
         ...
     };

     struct message {
         enum message_type type;

         void* body; // this would be cast to the correct data structure and would
                     // have to be dynamically allocated, if an allocation is
                     // necessary.
     };

     // place to update for a new message
     struct {
         void (*encode_message)(void);
         void (*decode_message)(void);
         void (*free_message)(void);
     } g_messages[] = {
         [MSG1] = { ...; ...; ...; },
         [MSG2] = { ...; ...; ...; }
     };
   #+end_src

   With the setup above, there are only two places where a message. without
   considering the functions that need to be written for the new message. This
   would be superior to the other system since it is more consolidated, and there
   is less room for error.

   One downside to this is that you have a void pointer in the message structure,
   which makes it a bit less ergonomic.

   Here is the thing, some messages will have data that will not be known at
   compile time. You will need to have dynamicallly allocated memory for these
   messages. Essentially anything that transmits a string falls into this category.

   you don't want to have body be cast to things such as vectors, since that would
   essentially mean doing two mallocs just for a single piece of data.

   when you receive data, it will be put into an expanding buffer. that data is
   then decoded into a message. for now, lets just keep doing it how you were, and
   malloc more than probably necessary. If if becomes a problem in the future, then
   we can fix it then.

   The encode message function should return a vector that contains the encoded
   body of the message


* Feature List
** TODO Multiple Scenarios
   - [ ] The Server can create new scenarios
   - [ ] The Server can remove scenarios.  Scenarios will not be removed if
     there are players still in them.
   - [ ] Users can ask the server to create new scenarios
   - [ ] Users can join and leave any scenario

** TODO Map Generation
*** TODO Map File Format for Static Maps
*** TODO Procedurally Generated Maps
** TODO [#A] Algorithm Library for Tank Control
   - [ ] path finding
   - [ ] target finding
   - [ ] squadron movement commands
** TODO [#B] Foreign Function Interfaces
   - [ ] Common Lisp
   - [ ] Python
   - [ ] Rust
   - [ ] Node JS
   - [ ] Go
   - [ ] Zig
** TODO More Ergonomic Client
*** TODO GUI Features
    - [ ] buttons
    - [ ] text
    - [ ] proper interface with the rest of the program
    - [ ] integrated console
*** TODO Flags
*** TODO Tank Listing
*** TODO Help Command
    Help by itself should list all the commands and a summary for each of them.
    ~help COMMAND~ Will provide detailed information on each command.
*** TODO Server Console
    should operate similarly to the client.  This will allow more graceful
    administration of the server.

    At a minimum, the server should have the following commands:
    - [ ] quit
    - [ ] kick
    - [ ] remove-scenario
    - [ ] add-scenario
    - [ ] help

* Code Quality List
  You need to do something about the vector structure.  You use it everywhere
  for a lot of things.  It is confusing what type is contained in a vector.
  Maybe some typedefs may be helpful?

** TODO vec_concat
   - [ ] write documentation
   - [ ] unit test

** TODO vec_byte_ref
   - [ ] write documentation
   - [ ] unit test
   
** TODO message functions
   - [ ] write unit tests
   - [ ] write documentation

** TODO Message Network Ordering
   Messages are constructed using host order, little endian.  They need to be
   sent in network order, big endian.
   
* Bug Fix List
** TODO ~connect~ command
   <2024-05-11 Sat>
   
   client segfaults when entering an invalid input on for the connect command

** TODO Disconnected users are retained on the server
   <2024-05-11 Sat>
   
   the server should clean up users that have disconnected, and shouldn't track
   them.  

** DONE Segfaults on Message Reception
   <2024-05-11 Sat>

   1) I found the message type on incoming messages was invalid.  The message
      type is used to index into an array of function pointers.  Since it was
      invalid, it resulted in a seg fault.
      - solved by checking for valid message types.
   2) The message types were invalid because of a casting error.  I originally
      had:

      #+begin_src c
        body_size = *(int*)(buf->data + sizeof(enum message_type));
      #+end_src

      which was changed to:

      #+begin_src c
        body_size = *(int*)vec_dat(buf) + sizeof(enum message_type);
      #+end_src

      The cast has higher precedence than the addition, so some random value in
      memory was being used as the message type.

   <2024-05-11 Sat>
